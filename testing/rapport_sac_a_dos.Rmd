---
title: 'Problème du sac à dos : 3 algorithmes comparés'
author: "Alexandre Combeau, Mohtadi Hammami, Ninette Hounkponou"
date: "2025-04-11"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
library(knapsack2)
library(Rcpp)

sourceCpp("C:\\Users\\alexa\\Desktop\\2024-2025\\Algorithmique\\knapsack2\\src\\rcpp_sac_a_dos.cpp")
```

# Description

Le **problème du sac à dos** est un problème classique d’optimisation combinatoire. On cherche à sélectionner un sous-ensemble d’objets, chacun ayant un poids et une valeur, de manière à **maximiser la valeur totale** transportée **sans dépasser une capacité maximale**.

Formellement :

Soient $n$ objets, chacun défini par :

- un poids $p_i\in\mathbb{N}^+$,

- une valeur $v_i\in\mathbb{R}^+$,

- un poids maximal autorisé $W\in\mathbb{N}^+$

L’objectif est de résoudre le problème suivant :

$$\max_{x\in\{0,1\}^n}\sum_{i=1}^{n}v_ix_i\quad\text{sous la contrainte}\quad \sum_{i=1}^{n}p_ix_i\le W$$
où $x_i=1$ signifie que l’objet $i$ est inclus dans le sac.

Nous présentons ici trois méthodes pour résoudre ce problème :

- Algorithme **brute force**

- Algorithme **glouton**

- Algorithme de **programmation dynamique**

---

# 1. Première méthode : Brut Force
## Description
L'algorithme **brute force** / **exhaustif**, consiste à regarder toutes les combinaisons possibles d'objets dans le sac, sans aucune optimisation préalable. Puisque nous disposons de $n$ objets, il y a exactement $2^n$ sous-ensembles possibles.

L'idée de base est donc de générer toutes les configurations binaires possibles de sélection d'objets $x\in\{0,1\}^n$. Pour CHAQUE configuration :

- on calcule le poids total : $p(x)=\sum_{i=1}^np_ix_i$

- on calcule la valeur totale : $v(x)=\sum_{i=1}^nv_ix_i$

Si $P(x)\le W$, alors la configuration est **valide** (mais pas optimale).

La configuration qui maximisera $v(x)$ sera donc la solution optimale.

```{r, include=FALSE}
sac_a_dos <- function(poids, valeurs, poids_max) {
  if (length(poids) != length(valeurs)) {
    stop("Les longueurs de 'poids' et 'valeurs' sont differentes.")
  }
  
  n <- length(poids)
  meilleure_valeur <- 0
  meilleur_combinaison <- rep(0, n)
  
  for (i in 0:(2^n - 1)) {
    combinaison <- as.integer(intToBits(i))[1:n]
    poids_total <- sum(poids * combinaison)
    valeur_totale <- sum(valeurs * combinaison)
    if (poids_total <= poids_max && valeur_totale > meilleure_valeur) {
      meilleure_valeur <- valeur_totale
      meilleur_combinaison <- combinaison
    }
  }
  
  return(list(combinaison = meilleur_combinaison,
              poids_total = sum(poids * meilleur_combinaison),
              valeur_totale = meilleure_valeur))
}
```

## Exemple

```{r exemple_naif}
set.seed(42)
n = 10
poids <- sample(10,n)
valeur <- sample(30,n)
poids_max <- 20
sac_a_dos(poids, valeur, poids_max)
```
## Complexité

L’algorithme teste toutes les $2^n$ combinaisons possibles.
Pour chaque combinaison, il fait deux opérations de somme sur $n$ éléments : $0(n)$.

La complexité totale est donc $$O(n2^n).$$


## Comparaison R / C++

```{r}
set.seed(42)
n <- 5
poids <- runif(n)
valeurs <- runif(n)
p_max <- 2
time1 <- system.time(sac_a_dos(poids, valeurs, p_max))
time2 <- system.time(rcpp_sac_a_dos(poids, valeurs, p_max))
time1[[1]]/time2[[1]]

# Comparaison des performances
library(microbenchmark)
res <- microbenchmark(
  sac_a_dos(poids, valeurs, p_max),       # Version R
  rcpp_sac_a_dos(poids, valeurs, p_max),  # Version C++
  times = 10
)
print(res)
library(ggplot2)
autoplot(res)
```

